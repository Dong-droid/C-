#include <iostream>
using namespace std;
using ll=long long;
const ll n_=3e6+100;
ll n,m,k,tc=1,a,b,c;
ll tree[n_],arr[n_];
ll init(ll N,ll s ,ll e){
	if(s==e) return tree[N]=arr[s];
	ll mid=(s+e)/2;
	return tree[N]=init(N*2,s,mid)+init(N*2+1,mid+1,e);
}
void update(ll N,ll s,ll e,ll idx,ll val){
	if(idx>e||idx<s) return;
	if(s==e){
		if(idx==s) tree[N]=val;
		return;
	}
	ll mid=(s+e)/2;
	update(N*2,s,mid,idx,val);
	update(N*2+1,mid+1,e,idx,val);
	tree[N]=tree[N*2]+tree[N*2+1];
}
ll query(ll N,ll s,ll e, ll l, ll r){
	if(l>e || r<s) return 0;
	if(l<=s&&e<=r) return tree[N];
	ll mid=(s+e)/2;
	return query(N*2,s,mid,l,r)+query(N*2+1,mid+1,e,l,r);
}
void solve(){
	cin>>n>>m>>k;
	for(int i=0;i<n;i++) cin>>arr[i];
	init(1,0,n-1);
	m+=k;
	while(m--){
		cin>>a>>b>>c;
		if(a==1) update(1,0,n-1,b-1,c);
		else cout<<query(1,0,n-1,b-1,c-1)<<'\n';
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	while(tc--) solve();
	return 0;
}
/////////////////////////////////////////////////////////
/*lazy-propagation*/

#include <cstdio>
#define MAXN 1000010 
#define ll long long 
ll arr[MAXN]; 
typedef struct Tree{ ll value, lazy; }Tree; Tree tree[3*MAXN];
//최초로 Segment트리의 대표값을 지정하는 함수 
ll init(int node, int start, int end){ 
if(start == end) return tree[node].value = arr[start];
else return tree[node].value = init(node*2, start, (start+end)/2)+init(node*2+1, (start+end)/2+1, end); 
} 
//i~j 구간에 diff만큼 더해줄 때 SegmentTree를 업데이트 하는 함수 
void update_range(int node, int start, int end, int i, int j, ll diff){ 
//lazy가 남아있을 때
if(tree[node].lazy != 0){
tree[node].value += (end-start+1)*tree[node].lazy;
if(start != end){ tree[node*2].lazy += tree[node].lazy; tree[node*2+1].lazy += tree[node].lazy; } 
tree[node].lazy =0; } 
if(j < start || i > end) return; //대표 구간을 찾았을 때
if(i <= start && end <= j){
tree[node].value += (end-start+1)*diff; if(start != end){
tree[node*2].lazy += diff; tree[node*2+1].lazy += diff; 
} return; 
} 
update_range(node*2, start, (start+end)/2, i, j, diff);
update_range(node*2+1, (start+end)/2+1, end, i, j, diff);
tree[node].value = tree[node*2].value+tree[node*2+1].value; } //i번째 값부터 j번째 값 까지의 합을 구하는 함수 
ll sum(int node, int start, int end, int i, int j){ 
if(tree[node].lazy != 0){ 
tree[node].value += (end-start+1)*tree[node].lazy; 
if(start != end){ tree[node*2].lazy += tree[node].lazy; tree[node*2+1].lazy += tree[node].lazy; } tree[node].lazy =0; }
if(i> end || j < start) return 0; if(i <= start && end <= j) return tree[node].value; return sum(node*2, start, (start+end)/2, i, j)+sum(node*2+1, (start+end)/2+1, end, i, j); }
int main(){ 
int N, M, K; scanf("%d%d%d", &N, &M, &K); for(int i=1; i<= N; i++) scanf("%lld", &arr[i]); init(1, 1, N); for(int i=1; i<= M+K; i++){
int t1, a, b; ll diff; scanf("%d", &t1); if(t1==1){ scanf("%d%d%lld", &a, &b, &diff); 
update_range(1, 1, N, a, b, diff); }
else{
scanf("%d%d", &a, &b); printf("%lld\n", sum(1, 1, N, a, b));
} 
} 
return 0; 
}

출처: https://bowbowbow.tistory.com/4 [멍멍멍]
